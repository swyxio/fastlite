[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "fastlite",
    "section": "",
    "text": "fastlite provides some little quality-of-life improvements for interactive use of the wonderful sqlite-utils library. It’s likely to be particularly of interest to folks using Jupyter.",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "fastlite",
    "section": "Install",
    "text": "Install\npip install fastlite",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "fastlite",
    "section": "Overview",
    "text": "Overview\n\nfrom fastlite import *\nfrom fastcore.utils import *\nfrom fastcore.net import urlsave\n\nWe demonstrate fastlite‘s features here using the ’chinook’ sample database.\n\nurl = 'https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite'\npath = Path('chinook.sqlite')\nif not path.exists(): urlsave(url, path)\n\ndb = database(\"chinook.sqlite\")\n\nDatabases have a t property that lists all tables:\n\ndt = db.t\ndt\n\nAlbum, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track\n\n\nYou can use this to grab a single table…:\n\nartist = dt.artists\nartist\n\n&lt;Table artists (does not exist yet)&gt;\n\n\n\nartist = dt.Artist\nartist\n\n&lt;Table Artist (ArtistId, Name)&gt;\n\n\n…or multiple tables at once:\n\ndt['Artist','Album','Track','Genre','MediaType']\n\n[&lt;Table Artist (ArtistId, Name)&gt;,\n &lt;Table Album (AlbumId, Title, ArtistId)&gt;,\n &lt;Table Track (TrackId, Name, AlbumId, MediaTypeId, GenreId, Composer, Milliseconds, Bytes, UnitPrice)&gt;,\n &lt;Table Genre (GenreId, Name)&gt;,\n &lt;Table MediaType (MediaTypeId, Name)&gt;]\n\n\nIt also provides auto-complete in Jupyter, IPython, and nearly any other interactive Python environment:\n\nYou can check if a table is in the database already:\n\n'Artist' in dt\n\nTrue\n\n\nColumn work in a similar way to tables, using the c property:\n\nac = artist.c\nac\n\nArtistId, Name\n\n\nAuto-complete works for columns too:\n\nColumns, tables, and view stringify in a format suitable for including in SQL statements. That means you can use auto-complete in f-strings.\n\nqry = f\"select * from {artist} where {ac.Name} like 'AC/%'\"\nprint(qry)\n\nselect * from \"Artist\" where \"Artist\".\"Name\" like 'AC/%'\n\n\nYou can view the results of a select query using q:\n\ndb.q(qry)\n\n[{'ArtistId': 1, 'Name': 'AC/DC'}]\n\n\nViews can be accessed through the v property:\n\nalbum = dt.Album\n\nacca_sql = f\"\"\"select {album}.*\nfrom {album} join {artist} using (ArtistId)\nwhere {ac.Name} like 'AC/%'\"\"\"\n\ndb.create_view(\"AccaDaccaAlbums\", acca_sql, replace=True)\nacca_dacca = db.q(f\"select * from {db.v.AccaDaccaAlbums}\")\nacca_dacca\n\n[{'AlbumId': 1,\n  'Title': 'For Those About To Rock We Salute You',\n  'ArtistId': 1},\n {'AlbumId': 4, 'Title': 'Let There Be Rock', 'ArtistId': 1}]",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "index.html#dataclass-support",
    "href": "index.html#dataclass-support",
    "title": "fastlite",
    "section": "Dataclass support",
    "text": "Dataclass support\nA dataclass type with the names, types, and defaults of the tables is created using dataclass():\n\nalbum_dc = album.dataclass()\n\nLet’s try it:\n\nalbum_obj = album_dc(**acca_dacca[0])\nalbum_obj\n\nAlbum(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1)\n\n\nYou can get the definition of the dataclass using fastcore’s dataclass_src – everything is treated as nullable, in order to handle auto-generated database values:\n\nsrc = dataclass_src(album_dc)\nhl_md(src, 'python')\n\n@dataclass\nclass Album:\n    AlbumId: int | None = None\n    Title: str | None = None\n    ArtistId: int | None = None\n\n\nBecause dataclass() is dynamic, you won’t get auto-complete in editors like vscode – it’ll only work in dynamic environments like Jupyter and IPython. For editor support, you can export the full set of dataclasses to a module, which you can then import from:\n\ncreate_mod(db, 'db_dc')\n\n\nfrom db_dc import Track\nTrack()\n\nTrack(TrackId=None, Name=None, AlbumId=None, MediaTypeId=None, GenreId=None, Composer=None, Milliseconds=None, Bytes=None, UnitPrice=None)\n\n\nIndexing into a table does a query on primary key:\n\ndt.Track[1]\n\nTrack(TrackId=1, Name='For Those About To Rock (We Salute You)', AlbumId=1, MediaTypeId=1, GenreId=1, Composer='Angus Young, Malcolm Young, Brian Johnson', Milliseconds=343719, Bytes=11170334, UnitPrice=0.99)\n\n\nThere’s a shortcut to select from a table – just call it as a function. If you’ve previously called dataclass(), returned iterms will be constructed using that class by default. There’s lots of params you can check out, such as limit:\n\nalbum(limit=2)\n\n[Album(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1),\n Album(AlbumId=2, Title='Balls to the Wall', ArtistId=2)]\n\n\nPass a truthy value as with_pk and you’ll get tuples of primary keys and records:\n\nalbum(with_pk=1, limit=2)\n\n[(1,\n  Album(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1)),\n (2, Album(AlbumId=2, Title='Balls to the Wall', ArtistId=2))]\n\n\nIndexing also uses the dataclass by default:\n\nalbum[5]\n\nAlbum(AlbumId=5, Title='Big Ones', ArtistId=3)\n\n\nIf you set xtra fields, then indexing is also filtered by those. As a result, for instance in this case, nothing is returned since album 5 is not created by artist 1:\n\nalbum.xtra(ArtistId=1)\n\ntry: album[5]\nexcept NotFoundError: print(\"Not found\")\n\nNot found\n\n\nThe same filtering is done when using the table as a callable:\n\nalbum()\n\n[Album(AlbumId=1, Title='For Those About To Rock We Salute You', ArtistId=1),\n Album(AlbumId=4, Title='Let There Be Rock', ArtistId=1)]",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "index.html#insert-upsert-and-update",
    "href": "index.html#insert-upsert-and-update",
    "title": "fastlite",
    "section": "Insert, upsert, and update",
    "text": "Insert, upsert, and update\nThe following methods accept **kwargs, passing them along to the first dict param:\n\ncreate\ntransform\ntransform_sql\nupdate\ninsert\nupsert\nlookup\n\nWe can access a table that doesn’t actually exist yet:\n\ncats = dt.cats\ncats\n\n&lt;Table cats (does not exist yet)&gt;\n\n\nWe can use keyword arguments to now create that table:\n\ncats.create(id=int, name=str, weight=float, uid=int, pk='id')\nhl_md(cats.schema, 'sql')\n\nCREATE TABLE [cats] (\n   [id] INTEGER PRIMARY KEY,\n   [name] TEXT,\n   [weight] FLOAT,\n   [uid] INTEGER\n)\n\n\nIt we set xtra then the additional fields are used for insert, update, and delete:\n\ncats.xtra(uid=2)\ncat = cats.insert(name='meow', weight=6)\n\nThe inserted row is returned, including the xtra ‘uid’ field.\n\ncat\n\n{'id': 1, 'name': 'meow', 'weight': 6.0, 'uid': 2}\n\n\nUsing ** in update here doesn’t actually achieve anything, since we can just pass a dict directly – it’s just to show that it works:\n\ncat['name'] = \"moo\"\ncat['uid'] = 1\ncats.update(**cat)\ncats()\n\n[{'id': 1, 'name': 'moo', 'weight': 6.0, 'uid': 2}]\n\n\nAttempts to update or insert with xtra fields are ignored.\nAn error is raised if there’s an attempt to update a record not matching xtra fields:\n\ncats.xtra(uid=1)\ntry: cats.update(**cat)\nexcept NotFoundError: print(\"Not found\")\n\nNot found\n\n\nThis all also works with dataclasses:\n\ncats.xtra(uid=2)\ncats.dataclass()\ncat = cats[1]\ncat\n\nCats(id=1, name='moo', weight=6.0, uid=2)\n\n\n\ncats.drop()\ncats\n\n&lt;Table cats (does not exist yet)&gt;\n\n\nAlternatively, you can create a table from a class. If it’s not already a dataclass, it will be converted into one. In either case, the dataclass will be created (or modified) so that None can be passed to any field (this is needed to support fields such as automatic row ids).\n\nclass Cat: id:int; name:str; weight:float; uid:int\n\n\ncats = db.create(Cat)\n\n\nhl_md(cats.schema, 'sql')\n\nCREATE TABLE [cat] (\n   [id] INTEGER PRIMARY KEY,\n   [name] TEXT,\n   [weight] FLOAT,\n   [uid] INTEGER\n)\n\n\n\ncat = Cat(name='咪咪', weight=9, uid=2)\ncats.insert(cat)\ncats()\n\n[Cat(id=1, name='咪咪', weight=9.0, uid=2)]\n\n\n\ncats.drop()",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "index.html#diagrams",
    "href": "index.html#diagrams",
    "title": "fastlite",
    "section": "Diagrams",
    "text": "Diagrams\nIf you have graphviz installed, you can create database diagrams:\n\ndiagram(db.tables)\n\n\n\n\n\n\n\n\nPass a subset of tables to just diagram those. You can also adjust the size and aspect ratio.\n\ndiagram(db.t['Artist','Album','Track','Genre','MediaType'], size=8, ratio=0.4)",
    "crumbs": [
      "fastlite"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Source",
    "section": "",
    "text": "from IPython.display import Markdown\n\n\ndb = Database(\"chinook.sqlite\")\n\n\nsource\n\n\n\n Database.t ()\n\n\n\nExported source\nclass _Getter:\n    \"Abstract class with dynamic attributes providing access to DB objects\"\n    def __init__(self, db): self.db = db\n    # NB: Define `__dir__` in subclass to get list of objects\n    def __repr__(self): return \", \".join(dir(self))\n    def __contains__(self, s): return (s if isinstance(s,str) else s.name) in dir(self)\n    def __getitem__(self, idxs):\n        if isinstance(idxs,str): return self.db.table(idxs)\n        return [self.db.table(o) for o in idxs]\n    def __getattr__(self, k):\n        if k[0]=='_': raise AttributeError\n        return self.db[k]\n\nclass _TablesGetter(_Getter):\n    def __dir__(self): return self.db.table_names()\n\n@patch(as_prop=True)\ndef t(self:Database): return _TablesGetter(self)\n\n\nBy returning a _TablesGetter we get a repr and auto-complete that shows all tables in the DB.\n\ndt = db.t\ndt\n\nAlbum, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track\n\n\n\nartist = dt.Artist\nartist\n\n&lt;Table Artist (ArtistId, Name)&gt;\n\n\nThis also can be used to get multiple tables at once.\n\ndt['Album','Artist']\n\n[&lt;Table Album (AlbumId, Title, ArtistId)&gt;, &lt;Table Artist (ArtistId, Name)&gt;]\n\n\n\nassert 'Artist' in dt\nassert artist in dt\nassert 'foo' not in dt\n\n\nsource\n\n\n\n\n View.c ()\n\n\n\nExported source\nclass _Col:\n    def __init__(self, t, c): self.t,self.c = t,c\n    def __str__(self):  return f'\"{self.t}\".\"{self.c}\"'\n    def __repr__(self):  return self.c\n    def __iter__(self): return iter(self.c)\n\nclass _ColsGetter:\n    def __init__(self, tbl): self.tbl = tbl\n    def __dir__(self): return map(repr, self())\n    def __call__(self): return [_Col(self.tbl.name,o.name) for o in self.tbl.columns]\n    def __contains__(self, s): return (s if isinstance(s,str) else s.c) in self.tbl.columns_dict\n    def __repr__(self): return \", \".join(dir(self))\n\n    def __getattr__(self, k):\n        if k[0]=='_': raise AttributeError\n        return _Col(self.tbl.name, k)\n\n@patch(as_prop=True)\ndef c(self:Table): return _ColsGetter(self)\n\n@patch(as_prop=True)\ndef c(self:View): return _ColsGetter(self)\n\n\n\nsource\n\n\n\n\n Table.c ()\n\nColumn auto-complete and repr are much the same as tables.\n\nac = artist.c\nac\n\nArtistId, Name\n\n\nColumns stringify in a format suitable for including in SQL statements.\n\nprint(f\"select {ac.Name} ...\")\n\nselect \"Artist\".\"Name\" ...\n\n\n\nsource\n\n\n\n\n View.__str__ ()\n\nReturn str(self).\n\n\nExported source\n@patch\ndef __str__(self:Table): return f'\"{self.name}\"'\n\n@patch\ndef __str__(self:View): return f'\"{self.name}\"'\n\n\n\nsource\n\n\n\n\n Table.__str__ ()\n\nReturn str(self).\nTables and views do the same.\n\nprint(f\"select {ac.Name} from {artist}\")\n\nselect \"Artist\".\"Name\" from \"Artist\"\n\n\n\nassert 'Name' in ac\nassert ac.Name in ac\nassert 'foo' not in ac",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "core.html#metadata",
    "href": "core.html#metadata",
    "title": "Source",
    "section": "",
    "text": "from IPython.display import Markdown\n\n\ndb = Database(\"chinook.sqlite\")\n\n\nsource\n\n\n\n Database.t ()\n\n\n\nExported source\nclass _Getter:\n    \"Abstract class with dynamic attributes providing access to DB objects\"\n    def __init__(self, db): self.db = db\n    # NB: Define `__dir__` in subclass to get list of objects\n    def __repr__(self): return \", \".join(dir(self))\n    def __contains__(self, s): return (s if isinstance(s,str) else s.name) in dir(self)\n    def __getitem__(self, idxs):\n        if isinstance(idxs,str): return self.db.table(idxs)\n        return [self.db.table(o) for o in idxs]\n    def __getattr__(self, k):\n        if k[0]=='_': raise AttributeError\n        return self.db[k]\n\nclass _TablesGetter(_Getter):\n    def __dir__(self): return self.db.table_names()\n\n@patch(as_prop=True)\ndef t(self:Database): return _TablesGetter(self)\n\n\nBy returning a _TablesGetter we get a repr and auto-complete that shows all tables in the DB.\n\ndt = db.t\ndt\n\nAlbum, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track\n\n\n\nartist = dt.Artist\nartist\n\n&lt;Table Artist (ArtistId, Name)&gt;\n\n\nThis also can be used to get multiple tables at once.\n\ndt['Album','Artist']\n\n[&lt;Table Album (AlbumId, Title, ArtistId)&gt;, &lt;Table Artist (ArtistId, Name)&gt;]\n\n\n\nassert 'Artist' in dt\nassert artist in dt\nassert 'foo' not in dt\n\n\nsource\n\n\n\n\n View.c ()\n\n\n\nExported source\nclass _Col:\n    def __init__(self, t, c): self.t,self.c = t,c\n    def __str__(self):  return f'\"{self.t}\".\"{self.c}\"'\n    def __repr__(self):  return self.c\n    def __iter__(self): return iter(self.c)\n\nclass _ColsGetter:\n    def __init__(self, tbl): self.tbl = tbl\n    def __dir__(self): return map(repr, self())\n    def __call__(self): return [_Col(self.tbl.name,o.name) for o in self.tbl.columns]\n    def __contains__(self, s): return (s if isinstance(s,str) else s.c) in self.tbl.columns_dict\n    def __repr__(self): return \", \".join(dir(self))\n\n    def __getattr__(self, k):\n        if k[0]=='_': raise AttributeError\n        return _Col(self.tbl.name, k)\n\n@patch(as_prop=True)\ndef c(self:Table): return _ColsGetter(self)\n\n@patch(as_prop=True)\ndef c(self:View): return _ColsGetter(self)\n\n\n\nsource\n\n\n\n\n Table.c ()\n\nColumn auto-complete and repr are much the same as tables.\n\nac = artist.c\nac\n\nArtistId, Name\n\n\nColumns stringify in a format suitable for including in SQL statements.\n\nprint(f\"select {ac.Name} ...\")\n\nselect \"Artist\".\"Name\" ...\n\n\n\nsource\n\n\n\n\n View.__str__ ()\n\nReturn str(self).\n\n\nExported source\n@patch\ndef __str__(self:Table): return f'\"{self.name}\"'\n\n@patch\ndef __str__(self:View): return f'\"{self.name}\"'\n\n\n\nsource\n\n\n\n\n Table.__str__ ()\n\nReturn str(self).\nTables and views do the same.\n\nprint(f\"select {ac.Name} from {artist}\")\n\nselect \"Artist\".\"Name\" from \"Artist\"\n\n\n\nassert 'Name' in ac\nassert ac.Name in ac\nassert 'foo' not in ac",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "core.html#queries-and-views",
    "href": "core.html#queries-and-views",
    "title": "Source",
    "section": "Queries and views",
    "text": "Queries and views\n\nsource\n\nDatabase.q\n\n Database.q (sql:str, params=None)\n\n\n\nExported source\n@patch\ndef q(self:Database, sql: str, params = None)-&gt;list:\n    return list(self.query(sql, params=params))\n\n\nThis is a minor shortcut for interactive use.\n\nacdc = db.q(f\"select * from {artist} where {ac.Name} like 'AC/%'\")\nacdc\n\n[{'ArtistId': 1, 'Name': 'AC/DC'}]\n\n\n\n\nExported source\ndef _get_flds(tbl): \n    return [(k, v|None, field(default=tbl.default_values.get(k,None)))\n            for k,v in tbl.columns_dict.items()]\n\ndef _dataclass(self:Table, store=True, suf='')-&gt;type:\n    \"Create a `dataclass` with the types and defaults of this table\"\n    res = make_dataclass(self.name.title()+suf, _get_flds(self))\n    if store: self.cls = res\n    return res\n\nTable.dataclass = _dataclass\n\n\n\nartist_dc = artist.dataclass()\nart1_obj = artist_dc(**acdc[0])\nart1_obj\n\nArtist(ArtistId=1, Name='AC/DC')\n\n\nYou can get the definition of the dataclass using fastcore’s dataclass_src:\n\nsrc = dataclass_src(artist_dc)\nhl_md(src, 'python')\n\n@dataclass\nclass Artist:\n    ArtistId: int | None = None\n    Name: str | None = None\n\n\n\nsource\n\n\nall_dcs\n\n all_dcs (db, with_views=False, store=True, suf='')\n\ndataclasses for all objects in db\n\n\nExported source\ndef all_dcs(db, with_views=False, store=True, suf=''):\n    \"dataclasses for all objects in `db`\"\n    return [o.dataclass(store=store, suf=suf) for o in db.tables + (db.views if with_views else [])]\n\n\n\nsource\n\n\ncreate_mod\n\n create_mod (db, mod_fn, with_views=False, store=True, suf='')\n\nCreate module for dataclasses for db\n\n\nExported source\ndef create_mod(db, mod_fn, with_views=False, store=True, suf=''):\n    \"Create module for dataclasses for `db`\"\n    mod_fn = str(mod_fn)\n    if not mod_fn.endswith('.py'): mod_fn+='.py'\n    with open(mod_fn, 'w') as f:\n        print('from dataclasses import dataclass', file=f)\n        print('from typing import Any,Union,Optional\\n', file=f)\n        for o in all_dcs(db, with_views, store=store, suf=suf): print(dataclass_src(o), file=f)\n\n\n\ncreate_mod(db, 'db_dc')\n\n\nfrom db_dc import Track\nTrack(**dt.Track.get(1))\n\nTrack(TrackId=1, Name='For Those About To Rock (We Salute You)', AlbumId=1, MediaTypeId=1, GenreId=1, Composer='Angus Young, Malcolm Young, Brian Johnson', Milliseconds=343719, Bytes=11170334, UnitPrice=0.99)\n\n\n\n\n\ncall’]\n*Built-in mutable sequence.\nIf no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.*\n\n\nExported source\n@patch\ndef __call__(\n    self:(Table|View), where:str|None=None,\n    where_args: Iterable|dict|NoneType=None, with_pk:bool=False, order_by: str|None=None,\n    limit:int|None=None, offset:int|None=None, as_cls:bool=True, **kwargs)-&gt;list:\n    \"Shortcut for `rows_where` or `pks_and_rows_where`, depending on `with_pk`\"\n\n    f = getattr(self, 'pks_and_rows_where' if with_pk else 'rows_where')\n    xtra = getattr(self, 'xtra_id', {})\n    if xtra:\n        xw = ' and '.join(f\"[{k}] = {v!r}\" for k,v in xtra.items())\n        where = f'{xw} and {where}' if where else xw\n    res = f(where=where, where_args=where_args, order_by=order_by, limit=limit, offset=offset, **kwargs)\n    if as_cls and hasattr(self,'cls'):\n        if with_pk: res = ((k,self.cls(**v)) for k,v in res)\n        else: res = (self.cls(**o) for o in res)\n    return list(res)\n\n\nThis calls either rows_where (if with_pk) or with_pk (otherwise). If dataclass(store=True) has been called, then if as_cls rows will be returned as dataclass objects.\n\nartist(limit=2)\n\n[Artist(ArtistId=1, Name='AC/DC'), Artist(ArtistId=2, Name='Accept')]\n\n\nIf with_pk then tuples are returns with PKs 1st.\n\nartist(with_pk=True, limit=2)\n\n[(1, Artist(ArtistId=1, Name='AC/DC')), (2, Artist(ArtistId=2, Name='Accept'))]\n\n\n\nartist.get(1)\n\n{'ArtistId': 1, 'Name': 'AC/DC'}\n\n\n\nalbum = dt.Album\n\nacca_sql = f\"\"\"select {album}.*\nfrom {album} join {artist} using (ArtistId)\nwhere {ac.Name} like 'AC/%'\"\"\"\n\n\nhl_md(acca_sql, 'sql')\n\nselect \"Album\".*\nfrom \"Album\" join \"Artist\" using (ArtistId)\nwhere \"Artist\".\"Name\" like 'AC/%'\n\n\n\ndb.q(acca_sql)\n\n[{'AlbumId': 1,\n  'Title': 'For Those About To Rock We Salute You',\n  'ArtistId': 1},\n {'AlbumId': 4, 'Title': 'Let There Be Rock', 'ArtistId': 1}]\n\n\n\ndb.create_view(\"AccaDaccaAlbums\", acca_sql, replace=True)\n\n&lt;Database &lt;sqlite3.Connection object&gt;&gt;\n\n\n\nsource\n\n\nDatabase.v\n\n Database.v ()\n\n\n\nExported source\nclass _ViewsGetter(_Getter):\n    def __dir__(self): return self.db.view_names()\n\n@patch(as_prop=True)\ndef v(self:Database): return _ViewsGetter(self)\n\n\n\ndv = db.v\ndv\n\nAccaDaccaAlbums\n\n\n\ndv.AccaDaccaAlbums()\n\n[{'AlbumId': 1,\n  'Title': 'For Those About To Rock We Salute You',\n  'ArtistId': 1},\n {'AlbumId': 4, 'Title': 'Let There Be Rock', 'ArtistId': 1}]\n\n\n\nsource\n\n\nDatabase.create\n\n Database.create (cls=None, name=None, pk='id', foreign_keys=None,\n                  defaults=None, column_order=None, not_null=None,\n                  hash_id=None, hash_id_columns=None, extracts=None,\n                  if_not_exists=False, replace=False, ignore=True,\n                  transform=False, strict=False)\n\nCreate table from cls, default name to snake-case version of class name\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncls\nNoneType\nNone\nDataclass to create table from\n\n\nname\nNoneType\nNone\nName of table to create\n\n\npk\nstr\nid\nColumn(s) to use as a primary key\n\n\nforeign_keys\nNoneType\nNone\nForeign key definitions\n\n\ndefaults\nNoneType\nNone\nDatabase table defaults\n\n\ncolumn_order\nNoneType\nNone\nWhich columns should come first\n\n\nnot_null\nNoneType\nNone\nColumns that should be created as NOT NULL\n\n\nhash_id\nNoneType\nNone\nColumn to be used as a primary key using hash\n\n\nhash_id_columns\nNoneType\nNone\nColumns used when calculating hash\n\n\nextracts\nNoneType\nNone\nColumns to be extracted during inserts\n\n\nif_not_exists\nbool\nFalse\nUse CREATE TABLE IF NOT EXISTS\n\n\nreplace\nbool\nFalse\nDrop and replace table if it already exists\n\n\nignore\nbool\nTrue\nSilently do nothing if table already exists\n\n\ntransform\nbool\nFalse\nIf table exists transform it to fit schema\n\n\nstrict\nbool\nFalse\nApply STRICT mode to table\n\n\n\n\n\nExported source\n@patch\ndef create(\n    self: Database,\n    cls=None,  # Dataclass to create table from\n    name=None,  # Name of table to create\n    pk='id',  # Column(s) to use as a primary key\n    foreign_keys=None,  # Foreign key definitions\n    defaults=None,  # Database table defaults\n    column_order=None,  # Which columns should come first\n    not_null=None,  # Columns that should be created as ``NOT NULL``\n    hash_id=None,  # Column to be used as a primary key using hash\n    hash_id_columns=None,  # Columns used when calculating hash\n    extracts=None,  # Columns to be extracted during inserts\n    if_not_exists=False,  # Use `CREATE TABLE IF NOT EXISTS`\n    replace=False,  # Drop and replace table if it already exists\n    ignore=True,  # Silently do nothing if table already exists\n    transform=False,  # If table exists transform it to fit schema\n    strict=False,  # Apply STRICT mode to table\n):\n    \"Create table from `cls`, default name to snake-case version of class name\"\n    mk_dataclass(cls)\n    if name is None: name = camel2snake(cls.__name__)\n    typs = {o.name: o.type for o in fields(cls)}\n    res = self.create_table(\n        name, typs, defaults=defaults,\n        pk=pk, foreign_keys=foreign_keys, column_order=column_order, not_null=not_null,\n        hash_id=hash_id, hash_id_columns=hash_id_columns, extracts=extracts, transform=transform,\n        if_not_exists=if_not_exists, replace=replace, ignore=ignore, strict=strict)\n    res.cls = cls\n    return res\n\n\nThe class you pass to create is converted to a dataclass where any fields missing a default are defaulted to None.\n\nclass Cat: id: int; name: str; age: int; city: str = \"Unknown\"\ncats = db.create(Cat)\nCat(1)\n\nCat(id=1, name=None, age=None, city='Unknown')\n\n\n\nprint(cats.schema)\n\nCREATE TABLE [cat] (\n   [id] INTEGER PRIMARY KEY,\n   [name] TEXT,\n   [age] INTEGER,\n   [city] TEXT\n)\n\n\n\ndb.t.cat.drop()",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "core.html#database-diagrams",
    "href": "core.html#database-diagrams",
    "title": "Source",
    "section": "Database diagrams",
    "text": "Database diagrams\n(Requires graphviz.)\n\nfk = album.foreign_keys[0]\nfk\n\nForeignKey(table='Album', column='ArtistId', other_table='Artist', other_column='ArtistId')\n\n\n\nsource\n\ndiagram\n\n diagram (tbls, ratio=0.7, size='10', neato=False, render=True)\n\n\n\nExported source\ndef _edge(tbl):\n    return \"\\n\".join(f\"{fk.table}:{fk.column} -&gt; {fk.other_table}:{fk.other_column};\"\n                     for fk in tbl.foreign_keys)\n\ndef _row(col):\n    xtra = \" 🔑\" if col.is_pk else \"\"\n    bg = ' bgcolor=\"#ffebcd\"' if col.is_pk else \"\"\n    return f'    &lt;tr&gt;&lt;td port=\"{col.name}\"{bg}&gt;{col.name}{xtra}&lt;/td&gt;&lt;/tr&gt;'\n\ndef _tnode(tbl):\n    rows = \"\\n\".join(_row(o) for o in tbl.columns)\n    res = f\"\"\"&lt;table cellborder=\"1\" cellspacing=\"0\"&gt;\n    &lt;tr&gt;&lt;td bgcolor=\"lightgray\"&gt;{tbl.name}&lt;/td&gt;&lt;/tr&gt;\n{rows}\n  &lt;/table&gt;\"\"\"\n    return f\"{tbl.name} [label=&lt;{res}&gt;];\\n\"\n\n\n\n\nExported source\ndef diagram(tbls, ratio=0.7, size=\"10\", neato=False, render=True):\n    layout = \"\\nlayout=neato;\\noverlap=prism;\\noverlap_scaling=0.5;\"\"\" if neato else \"\"\n    edges  = \"\\n\".join(map(_edge,  tbls))\n    tnodes = \"\\n\".join(map(_tnode, tbls))\n    \n    res = f\"\"\"digraph G {{\nrankdir=LR;{layout}\nsize=\"{size}\";\nratio={ratio};\nnode [shape=plaintext]\n\n{tnodes}\n\n{edges}\n}}\n\"\"\"\n    return Source(res) if render else res\n\n\n\ndiagram(db.tables)",
    "crumbs": [
      "Source"
    ]
  }
]